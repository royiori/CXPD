//*********************************************
//  This is auto generated by G4gen 0.6
//                                  author:Qian

#ifndef MyDetectorConstruction_h
#define MyDetectorConstruction_h

#include "G4VUserDetectorConstruction.hh"
#include "globals.hh"

class G4Box;
class G4Tubs;
class G4CSGSolid;
class G4LogicalVolume;
class G4VPhysicalVolume;
class G4Region;
class G4Material;
class G4UserLimits;
class G4GlobalMagFieldMessenger;
class G4VisAttributes;

class MyDetectorMessenger;

//-------------------------------
// detector parameter variables

#define SIZE 50
#define WORLD 0
#define SHIELD1 1
#define INNER 2
#define KOVAR1 3
#define COLLIMATION1 4
#define WINDOW 5
#define GAS 6
#define CERAMICS 7
#define KOVAR2 8
#define KOVAR3 9
#define ANTICSHIELD 10
#define ANTICSHIELD2 11

//-------------------------------
// detector parameter class
class MyDetectorParameters
{
public:
  MyDetectorParameters()
  {
    Name = "";
    Matt = "";
    VType = "";
    MID = 0;
    for (int i = 0; i < 10; i++)
      Siz[i] = 0;
    for (int i = 0; i < 3; i++)
      Pos[i] = 0;
    for (int i = 0; i < 3; i++)
      Rot[i] = 0;
    Material = 0;
    visAtt = 0;
    Region = 0;
    RegionName = "";
  }

  virtual ~MyDetectorParameters(){};

  G4int MID;
  G4String Name;
  G4String Matt;
  G4String VType;
  G4double Siz[10];
  G4double Pos[3];
  G4double Rot[3];
  G4Material *Material;
  G4VisAttributes *visAtt;
  G4Region *Region;
  G4String RegionName;
};

//-------------------------------
// detector contructions
class MyDetectorConstruction : public G4VUserDetectorConstruction
{
public:
  MyDetectorConstruction();
  virtual ~MyDetectorConstruction();

  G4VPhysicalVolume *DefineVolumes();
  virtual G4VPhysicalVolume *Construct();

  void SetMaterial(int, G4String);
  void Update();

public:
  void SetWorldSizeHalfX(G4double x) { fDetPar[WORLD]->Siz[0] = x; }
  void SetWorldSizeHalfY(G4double y) { fDetPar[WORLD]->Siz[1] = y; }
  void SetWorldSizeHalfZ(G4double z) { fDetPar[WORLD]->Siz[2] = z; }
  G4double GetWorldSizeHalfX() { return fDetPar[WORLD]->Siz[0]; }
  G4double GetWorldSizeHalfY() { return fDetPar[WORLD]->Siz[1]; }
  G4double GetWorldSizeHalfZ() { return fDetPar[WORLD]->Siz[2]; }

  void SetWindowSizeHalfX(G4double x) { fDetPar[WINDOW]->Siz[0] = x; }
  void SetWindowSizeHalfY(G4double y) { fDetPar[WINDOW]->Siz[1] = y; }
  void SetWindowSizeHalfZ(G4double z) { fDetPar[WINDOW]->Siz[2] = z; }
  G4double GetWindowSizeHalfX() { return fDetPar[WINDOW]->Siz[0]; }
  G4double GetWindowSizeHalfY() { return fDetPar[WINDOW]->Siz[1]; }
  G4double GetWindowSizeHalfZ() { return fDetPar[WINDOW]->Siz[2]; }

  void SetGasSizeHalfX(G4double x) { fDetPar[GAS]->Siz[0] = x; }
  void SetGasSizeHalfY(G4double y) { fDetPar[GAS]->Siz[1] = y; }
  void SetGasSizeHalfZ(G4double z) { fDetPar[GAS]->Siz[2] = z; }
  G4double GetGasSizeHalfX() { return fDetPar[GAS]->Siz[0]; }
  G4double GetGasSizeHalfY() { return fDetPar[GAS]->Siz[1]; }
  G4double GetGasSizeHalfZ() { return fDetPar[GAS]->Siz[2]; }

  G4bool InGasDetector(const G4ThreeVector aPosition) const { 
    if(aPosition.x() < fDetPar[GAS]->Siz[0] && aPosition.x() > -fDetPar[GAS]->Siz[0] && aPosition.y() < fDetPar[GAS]->Siz[1] && aPosition.y() > -fDetPar[GAS]->Siz[1] && aPosition.z() <= fDetPar[GAS]->Siz[2] && aPosition.z() >= -fDetPar[GAS]->Siz[2])
      return true; 

    return false;
  }

  G4LogicalVolume *GetAnticShieldVolume() const { return fAnticShieldVolume; }
  G4LogicalVolume *GetAnticShieldVolume2() const { return fAnticShieldVolume2; }
	G4LogicalVolume *GetBeWindowsVolume() const {return fBeWindowsVolume;}
	G4LogicalVolume *GetGasVolume() const {return fGasVolume;}

protected:
  G4LogicalVolume *fAnticShieldVolume;
  G4LogicalVolume *fAnticShieldVolume2;
	G4LogicalVolume *fBeWindowsVolume;
	G4LogicalVolume *fGasVolume;

private:
  void DefineMaterials();

  MyDetectorMessenger *fDetectorMessenger;

  G4bool checkOverlaps;
  G4UserLimits *fStepLimit;

  MyDetectorParameters *fDetPar[SIZE];
  G4CSGSolid *fSolid[SIZE];
  G4LogicalVolume *fLogic[SIZE];
  G4VPhysicalVolume *fPhysc[SIZE];

};

#endif
