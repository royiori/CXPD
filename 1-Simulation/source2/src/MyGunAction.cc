//*********************************************
//  This is auto generated by G4gen 0.6
//                                  author:Qian

#include "G4LogicalVolumeStore.hh"
#include "G4LogicalVolume.hh"
#include "G4Box.hh"
#include "G4Event.hh"
#include "G4ParticleGun.hh"
#include "G4GeneralParticleSource.hh"
#include "G4ParticleTable.hh"
#include "G4ParticleDefinition.hh"
#include "G4SystemOfUnits.hh"
#include "Verbose.hh"
#include "Randomize.hh"
//#include <time.h>
#include <cmath>
#include "G4RotationMatrix.hh"
#include "G4Transform3D.hh"

#include "MyGunAction.hh"
//#define random(x)(rand()%x)
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

using namespace std;

MyGunAction *MyGunAction::fInstance = 0;

MyGunAction::MyGunAction()
    : G4VUserPrimaryGeneratorAction(), fParticleGun(0), fParticleSourceGun(0)
{
    if (verbose)
        G4cout << "====>MyGunAction::MyGunAction()" << G4endl;
    fPGorGPS = true; //false for GPS, true for Particle Gun

    G4int nofParticles = 1;
    fParticleGun = new G4ParticleGun(nofParticles);
    // default particle kinematic
    G4ParticleTable *particleTable = G4ParticleTable::GetParticleTable();
    G4ParticleDefinition *particle = particleTable->FindParticle("geantino");
    fParticleGun->SetParticleDefinition(particle);

    gunEng = 100 * GeV;
    gunPos = G4ThreeVector(0., 0., 0.);
    gunDirection = G4ThreeVector(0., 0., 1.);
    gunPolarization = G4ThreeVector(1., 0., 0.);
    fParticleGun->SetParticleEnergy(gunEng);
    fParticleGun->SetParticleMomentumDirection(gunDirection);
    fParticleGun->SetParticlePosition(gunPos);

    //SetParticle();
    //create a messenger for this class
    fGunMessenger = new MyGunMessenger(this);

    fRootFile = G4String("./root/tmp.root");
    fTxtFile = G4String("./gif/tmp.txt");
    fProgFile = G4String("./gif/progress.txt");

    fParticleSourceGun = new G4GeneralParticleSource();
    fParticleSourceGun->SetParticleDefinition(particle);
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

MyGunAction::~MyGunAction()
{
    delete fParticleGun;
    delete fParticleSourceGun;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void MyGunAction::SetParticle()
{
    theparax = gunPos[0];
    theparay = gunPos[1];
    theparaz = gunPos[2];
    momenDirecX = gunDirection[0];
    momenDirecY = gunDirection[1];
    momenDirecZ = gunDirection[2];

    //.. do the calculation
    //.. 1. get the Z of window

    //G4double kovarposi = 32.5 * mm;
    G4LogicalVolume *kovarLV = G4LogicalVolumeStore::GetInstance()->GetVolume("Collimation1");
    G4Box *kovarBox = NULL;
    if (kovarLV)
        kovarBox = dynamic_cast<G4Box *>(kovarLV->GetSolid());

    G4double kovarXlength = 0;
    G4double kovarYlength = 0;
    G4double kovarZlength = 60;
    G4double lunchsquareX = 0;
    G4double lunchsquareY = 0;
    G4double lunchsquareZ = 0;

    if (kovarBox)
    {
        kovarXlength = kovarBox->GetXHalfLength();
        kovarYlength = kovarBox->GetYHalfLength();
        kovarZlength = kovarBox->GetZHalfLength();
    }

    //.. 2. get the R of the projection sphere
    double R = 200 * mm; // choose a sufficient large R to make sure the detector is covered inside.

    //.. 3. calculate the projection point
    G4double sideXY = sqrt(pow(momenDirecX, 2) + pow(momenDirecY, 2));
    G4double sideXYZ = sqrt(pow(momenDirecX, 2) + pow(momenDirecY, 2) + pow(momenDirecZ, 2));
    if (sideXYZ == 0)
    {
        G4cout << "something is wrong!" << G4endl;
    }
    else
    {
        G4double angleZ_XY = acos(sideXY / sideXYZ);
        if (sideXY == 0)
        {
            lunchsquareZ = R * sin(angleZ_XY) + theparax;
            lunchsquareX = theparax;
            lunchsquareY = theparay;
        }
        else
        {
            G4double angleXY = acos(momenDirecY / sideXY);
            lunchsquareZ = R * sin(angleZ_XY) + theparaz;
            lunchsquareX = -R * cos(angleZ_XY) * sin(angleXY) + theparax;
            lunchsquareY = -R * cos(angleZ_XY) * cos(angleXY) + theparay;
        }
    }

    G4ThreeVector newgunPos = G4ThreeVector(lunchsquareX, lunchsquareY, lunchsquareZ); //a

    //.. 4. calculate the polarization vector
    G4ThreeVector newaxisZ = gunDirection.unit();
    G4ThreeVector newaxisY = newaxisZ.cross(G4ThreeVector(1, 0, 0));
    if (newaxisY == G4ThreeVector(0, 0, 0))
        newaxisY = G4ThreeVector(0, 0, 1);

    G4ThreeVector newaxisX = newaxisY.cross(newaxisZ);
    G4RotationMatrix rotMatrix = G4RotationMatrix(newaxisX, newaxisY, newaxisZ);
    G4ThreeVector newPola = rotMatrix * gunPolarization.unit();

    //.. 5. set the gun

    fParticleGun->SetParticleEnergy(gunEng);
    fParticleGun->SetParticleMomentumDirection(gunDirection);
    fParticleGun->SetParticlePosition(newgunPos);
    fParticleGun->SetParticlePolarization(newPola);
    //G4cout<<"====+++=== "<<newPola<<G4endl;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void MyGunAction::GeneratePrimaries(G4Event *anEvent)
{
    if (verbose)
        G4cout << "====>MyGunAction::GeneratePrimaries()" << G4endl;
    donPDGID = fParticleGun->GetParticleDefinition()->GetPDGEncoding();
    //G4cout<<"+++++++++++++++++++++++++  "<<donPDGID<<G4endl;
    if (fPGorGPS == true)
    {
        //SetParticle();
        fParticleGun->GeneratePrimaryVertex(anEvent);
    }
    else
        fParticleSourceGun->GeneratePrimaryVertex(anEvent);
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
